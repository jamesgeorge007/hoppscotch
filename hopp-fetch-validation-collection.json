{
  "v": 10,
  "id": "cmhpz2ftj01esp90majuvpg22",
  "name": "hopp.fetch() Validation Collection",
  "folders": [],
  "requests": [
    {
      "v": "16",
      "id": "async_patterns_prereq",
      "name": "Async Patterns - Pre-Request",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Top-level await (most common pattern)\nconst response1 = await hopp.fetch('https://echo.hoppscotch.io?test=toplevel-await')\nconst data1 = await response1.json()\nhopp.env.active.set('async_toplevel_status', response1.status.toString())\nhopp.env.active.set('async_toplevel_arg', data1.args.test)\n\n// Test 2: .then() chaining pattern\nhopp.fetch('https://echo.hoppscotch.io?test=then-chain')\n  .then(response => {\n    hopp.env.active.set('async_then_status', response.status.toString())\n    return response.json()\n  })\n  .then(data => {\n    hopp.env.active.set('async_then_arg', data.args.test)\n  })\n\n// Test 3: Mixed pattern - await with .then()\nawait hopp.fetch('https://echo.hoppscotch.io?test=mixed')\n  .then(async response => {\n    hopp.env.active.set('async_mixed_status', response.status.toString())\n    const data = await response.json()\n    hopp.env.active.set('async_mixed_arg', data.args.test)\n  })\n\n// Test 4: Promise.all with await\nconst [r1, r2] = await Promise.all([\n  hopp.fetch('https://echo.hoppscotch.io?test=parallel1'),\n  hopp.fetch('https://echo.hoppscotch.io?test=parallel2')\n])\nconst [d1, d2] = await Promise.all([r1.json(), r2.json()])\nhopp.env.active.set('async_parallel1', d1.args.test)\nhopp.env.active.set('async_parallel2', d2.args.test)\n",
      "testScript": "hopp.test('Pre-request top-level await works', () => {\n  hopp.expect(hopp.env.active.get('async_toplevel_status')).toBe('200')\n  hopp.expect(hopp.env.active.get('async_toplevel_arg')).toBe('toplevel-await')\n})\n\nhopp.test('Pre-request .then() chain works', () => {\n  hopp.expect(hopp.env.active.get('async_then_status')).toBe('200')\n  hopp.expect(hopp.env.active.get('async_then_arg')).toBe('then-chain')\n})\n\nhopp.test('Pre-request mixed await/.then() works', () => {\n  hopp.expect(hopp.env.active.get('async_mixed_status')).toBe('200')\n  hopp.expect(hopp.env.active.get('async_mixed_arg')).toBe('mixed')\n})\n\nhopp.test('Pre-request Promise.all works', () => {\n  hopp.expect(hopp.env.active.get('async_parallel1')).toBe('parallel1')\n  hopp.expect(hopp.env.active.get('async_parallel2')).toBe('parallel2')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsk_d37e1eb0-b001-4c18-bf23-50a0d69b1688"
    },
    {
      "v": "16",
      "id": "async_patterns_test",
      "name": "Async Patterns - Test Script",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Empty pre-request - all tests in test script\n",
      "testScript": "// Test 1: Top-level await in test script\nconst response1 = await hopp.fetch('https://echo.hoppscotch.io?test=test-toplevel')\nconst data1 = await response1.json()\n\nhopp.test('Test script top-level await works', () => {\n  hopp.expect(response1.status).toBe(200)\n  hopp.expect(data1.args.test).toBe('test-toplevel')\n})\n\n// Test 2: await inside hopp.test callback\nhopp.test('Await inside test callback works', async () => {\n  const response = await hopp.fetch('https://echo.hoppscotch.io?test=inside-callback')\n  hopp.expect(response.status).toBe(200)\n  const data = await response.json()\n  hopp.expect(data.args.test).toBe('inside-callback')\n})\n\n// Test 3: .then() inside test callback\nhopp.test('.then() inside test callback works', () => {\n  return hopp.fetch('https://echo.hoppscotch.io?test=then-callback')\n    .then(response => {\n      hopp.expect(response.status).toBe(200)\n      return response.json()\n    })\n    .then(data => {\n      hopp.expect(data.args.test).toBe('then-callback')\n    })\n})\n\n// Test 4: Mixed pattern in test\nhopp.test('Mixed pattern in test works', async () => {\n  await hopp.fetch('https://echo.hoppscotch.io?test=mixed-test')\n    .then(response => response.json())\n    .then(data => {\n      hopp.expect(data.args.test).toBe('mixed-test')\n    })\n})\n\n// Test 5: Promise.all in test callback\nhopp.test('Promise.all in test callback works', async () => {\n  const responses = await Promise.all([\n    hopp.fetch('https://echo.hoppscotch.io?id=1'),\n    hopp.fetch('https://echo.hoppscotch.io?id=2')\n  ])\n  hopp.expect(responses[0].status).toBe(200)\n  hopp.expect(responses[1].status).toBe(200)\n  const dataArray = await Promise.all(responses.map(r => r.json()))\n  hopp.expect(dataArray[0].args.id).toBe('1')\n  hopp.expect(dataArray[1].args.id).toBe('2')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsk_c306d08b-c0a9-40f7-bec1-be15e644fc1c"
    },
    {
      "v": "16",
      "id": "get_methods_combined",
      "name": "GET Methods (Query, Headers, URL)",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Query parameters\nconst qResponse = await hopp.fetch('https://echo.hoppscotch.io?foo=bar&baz=qux&test=123')\nconst qData = await qResponse.json()\nhopp.env.active.set('query_foo', qData.args.foo || 'missing')\nhopp.env.active.set('query_baz', qData.args.baz || 'missing')\nhopp.env.active.set('query_test', qData.args.test || 'missing')\n\n// Test 2: Custom headers (using httpbin.org for CORS compatibility)\nconst hResponse = await hopp.fetch('https://httpbin.org/get', {\n  headers: {\n    'X-Custom-Header': 'CustomValue123',\n    'X-API-Key': 'secret-key-456',\n    'User-Agent': 'HoppscotchTest/1.0'\n  }\n})\nconst hData = await hResponse.json()\nhopp.env.active.set('custom_header', hData.headers['X-Custom-Header'] || 'missing')\nhopp.env.active.set('api_key_header', hData.headers['X-Api-Key'] || 'missing')\n\n// Test 3: URL object\nconst urlObj = new URL('https://echo.hoppscotch.io')\nurlObj.searchParams.append('url_test', 'url-object')\nurlObj.searchParams.append('value', '42')\nconst uResponse = await hopp.fetch(urlObj)\nconst uData = await uResponse.json()\nhopp.env.active.set('url_obj_test', uData.args.url_test)\nhopp.env.active.set('url_obj_value', uData.args.value)\n\n// Test 4: Special characters\nconst searchQuery = 'test & special = chars'\nconst encodedQuery = encodeURIComponent(searchQuery)\nconst sResponse = await hopp.fetch(`https://echo.hoppscotch.io?q=${encodedQuery}&other=value`)\nconst sData = await sResponse.json()\nhopp.env.active.set('special_chars_q', sData.args.q)\nhopp.env.active.set('special_chars_other', sData.args.other)\n",
      "testScript": "hopp.test('Query parameters work', () => {\n  hopp.expect(hopp.env.active.get('query_foo')).toBe('bar')\n  hopp.expect(hopp.env.active.get('query_baz')).toBe('qux')\n  hopp.expect(hopp.env.active.get('query_test')).toBe('123')\n})\n\nhopp.test('Custom headers work', () => {\n  hopp.expect(hopp.env.active.get('custom_header')).toBe('CustomValue123')\n  hopp.expect(hopp.env.active.get('api_key_header')).toBe('secret-key-456')\n})\n\nhopp.test('URL object works', () => {\n  hopp.expect(hopp.env.active.get('url_obj_test')).toBe('url-object')\n  hopp.expect(hopp.env.active.get('url_obj_value')).toBe('42')\n})\n\nhopp.test('Special characters in URL work', () => {\n  hopp.expect(hopp.env.active.get('special_chars_q')).toBe('test & special = chars')\n  hopp.expect(hopp.env.active.get('special_chars_other')).toBe('value')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_b6594ff5-c1a3-4550-ae44-17567bb0453a"
    },
    {
      "v": "16",
      "id": "post_methods_combined",
      "name": "POST Methods (JSON, URLEncoded, Binary)",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: POST with JSON body (await pattern)\nconst jsonBody = {\n  name: 'John Doe',\n  email: 'john@example.com',\n  age: 30,\n  active: true\n}\n\nconst jsonResponse = await hopp.fetch('https://echo.hoppscotch.io', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(jsonBody)\n})\nconst jsonData = await jsonResponse.json()\nconst receivedJson = JSON.parse(jsonData.data)\nhopp.env.active.set('post_json_name', receivedJson.name)\nhopp.env.active.set('post_json_email', receivedJson.email)\n\n// Test 2: POST with URL-encoded body (using httpbin.org for CORS compatibility - .then pattern)\nconst params = new URLSearchParams()\nparams.append('username', 'testuser')\nparams.append('password', 'testpass123')\n\nawait hopp.fetch('https://httpbin.org/post', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n  body: params.toString()\n}).then(response => response.json())\n  .then(data => {\n    // httpbin.org puts form-encoded data in 'form' field, not 'data'\n    hopp.env.active.set('urlencoded_data', JSON.stringify(data.form) || 'missing')\n    hopp.env.active.set('urlencoded_ct', data.headers['Content-Type'] || 'missing')\n  })\n\n// Test 3: Binary POST\nconst binaryData = new Uint8Array([0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x21]) // \"Hello!\"\nawait hopp.fetch('https://echo.hoppscotch.io', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/octet-stream' },\n  body: binaryData\n}).then(r => r.json()).then(d => {\n  hopp.env.active.set('binary_method', d.method)\n  hopp.env.active.set('binary_ct', d.headers['content-type'] || 'missing')\n})\n\n// Test 4: Empty body POST\nconst emptyResponse = await hopp.fetch('https://echo.hoppscotch.io', {\n  method: 'POST'\n})\nconst emptyData = await emptyResponse.json()\nhopp.env.active.set('empty_post_method', emptyData.method)\n",
      "testScript": "hopp.test('POST JSON body works', () => {\n  hopp.expect(hopp.env.active.get('post_json_name')).toBe('John Doe')\n  hopp.expect(hopp.env.active.get('post_json_email')).toBe('john@example.com')\n})\n\nhopp.test('POST URL-encoded body works', () => {\n  const formData = hopp.env.active.get('urlencoded_data')\n  hopp.expect(formData).toInclude('testuser')\n  hopp.expect(formData).toInclude('testpass123')\n  hopp.expect(hopp.env.active.get('urlencoded_ct')).toInclude('application/x-www-form-urlencoded')\n})\n\nhopp.test('Binary POST works', () => {\n  hopp.expect(hopp.env.active.get('binary_method')).toBe('POST')\n  hopp.expect(hopp.env.active.get('binary_ct')).toInclude('application/octet-stream')\n})\n\nhopp.test('Empty body POST works', () => {\n  hopp.expect(hopp.env.active.get('empty_post_method')).toBe('POST')\n})\n\n// Test 5: POST in test script with .then()\nhopp.test('POST in test script works', () => {\n  return hopp.fetch('https://echo.hoppscotch.io', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ test: 'from-test-script' })\n  }).then(r => r.json()).then(d => {\n    const body = JSON.parse(d.data)\n    hopp.expect(body.test).toBe('from-test-script')\n  })\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_9a095d90-435e-4aed-bf8e-8f0e6df938db"
    },
    {
      "v": "16",
      "id": "http_methods_combined",
      "name": "HTTP Methods (PUT, PATCH, DELETE)",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test PUT with mixed async\nawait hopp.fetch('https://echo.hoppscotch.io', {\n  method: 'PUT',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ id: 123, name: 'Updated' })\n}).then(r => r.json()).then(d => {\n  hopp.env.active.set('put_method', d.method)\n})\n\n// Test PATCH with await\nconst patchResp = await hopp.fetch('https://echo.hoppscotch.io', {\n  method: 'PATCH',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ field: 'updated' })\n})\nconst patchData = await patchResp.json()\nhopp.env.active.set('patch_method', patchData.method)\n\n// Test DELETE with .then\nhopp.fetch('https://echo.hoppscotch.io/resource/123', {\n  method: 'DELETE'\n}).then(r => r.json()).then(d => {\n  hopp.env.active.set('delete_method', d.method)\n  hopp.env.active.set('delete_path', d.path || 'missing')\n})\n",
      "testScript": "hopp.test('PUT method works', () => {\n  hopp.expect(hopp.env.active.get('put_method')).toBe('PUT')\n})\n\nhopp.test('PATCH method works', () => {\n  hopp.expect(hopp.env.active.get('patch_method')).toBe('PATCH')\n})\n\nhopp.test('DELETE method works', () => {\n  hopp.expect(hopp.env.active.get('delete_method')).toBe('DELETE')\n  hopp.expect(hopp.env.active.get('delete_path')).toInclude('/resource/123')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_82e1b611-e2ae-4e3b-9b91-0df4fbadfed1"
    },
    {
      "v": "16",
      "id": "response_parsing_combined",
      "name": "Response Parsing (Headers, Status, Body)",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "const response = await hopp.fetch('https://echo.hoppscotch.io')\n\n// Test headers access\nconst contentType = response.headers.get('content-type')\nlet headerCount = 0\nfor (const [key, value] of response.headers.entries()) {\n  headerCount++\n}\n\nif (contentType) {\n  hopp.env.active.set('has_content_type', (contentType !== null).toString())\n}\n\nhopp.env.active.set('header_count', headerCount.toString())\n\n// Test status properties\nhopp.env.active.set('resp_status', response.status.toString())\nhopp.env.active.set('resp_ok', response.ok.toString())\nhopp.env.active.set('resp_status_text', response.statusText || 'empty')\n\n// Test text parsing\nconst text = await response.text()\nhopp.env.active.set('text_length', text.length.toString())\nhopp.env.active.set('is_string', (typeof text === 'string').toString())\n",
      "testScript": "hopp.test('Response headers accessible', () => {\n  // Agent interceptor doesn't return content type\n  const hasContentType = hopp.env.active.get('has_content_type')\n  if (hasContentType) {\n    hopp.expect(hopp.env.active.get('has_content_type')).toBe('true')\n  }\n\n  const headerCount = parseInt(hopp.env.active.get('header_count'))\n  hopp.expect(headerCount > 0).toBe(true)\n})\n\nhopp.test('Response status properties work', () => {\n  hopp.expect(hopp.env.active.get('resp_status')).toBe('200')\n  hopp.expect(hopp.env.active.get('resp_ok')).toBe('true')\n})\n\nhopp.test('response.text() works', () => {\n  const textLength = parseInt(hopp.env.active.get('text_length'))\n  hopp.expect(textLength > 0).toBe(true)\n  hopp.expect(hopp.env.active.get('is_string')).toBe('true')\n})\n\n// Test async parsing in test script\nhopp.test('Async response parsing in test works', async () => {\n  const response = await hopp.fetch('https://echo.hoppscotch.io?test=parse')\n  const data = await response.json()\n  hopp.expect(data.args.test).toBe('parse')\n\n  // Agent interceptor doesn't return content type\n  const contentType = response.headers.get('content-type')\n  if (contentType) {\n    hopp.expect(contentType).toInclude('json')\n  }\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_257c420b-ea26-43a7-b9b8-906744e5d5dc"
    },
    {
      "v": "16",
      "id": "workflow_patterns",
      "name": "Workflow Patterns (Sequential, Parallel, Auth)",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Sequential requests with .then chaining\nhopp.fetch('https://echo.hoppscotch.io?step=1')\n  .then(r => r.json())\n  .then(d1 => {\n    hopp.env.active.set('seq_step1', d1.args.step)\n    return hopp.fetch(`https://echo.hoppscotch.io?step=2&prev=${d1.args.step}`)\n  })\n  .then(r => r.json())\n  .then(d2 => {\n    hopp.env.active.set('seq_step2', d2.args.step)\n    hopp.env.active.set('seq_prev', d2.args.prev)\n  })\n\n// Test 2: Parallel with Promise.all and mixed patterns\nconst parallelPromises = [\n  hopp.fetch('https://echo.hoppscotch.io?id=1').then(r => r.json()),\n  hopp.fetch('https://echo.hoppscotch.io?id=2').then(r => r.json()),\n  hopp.fetch('https://echo.hoppscotch.io?id=3').then(r => r.json())\n]\n\nawait Promise.all(parallelPromises).then(results => {\n  hopp.env.active.set('parallel_id1', results[0].args.id)\n  hopp.env.active.set('parallel_id2', results[1].args.id)\n  hopp.env.active.set('parallel_id3', results[2].args.id)\n})\n\n// Test 3: Auth workflow (using httpbin.org for CORS compatibility)\nconst authResp = await hopp.fetch('https://httpbin.org/get?action=login&user=testuser')\nconst authData = await authResp.json()\nconst token = `${authData.args.action}_token_${authData.args.user}`\nhopp.env.active.set('workflow_token', token)\n\nconst dataResp = await hopp.fetch('https://httpbin.org/get?action=fetch', {\n  headers: { 'Authorization': `Bearer ${token}` }\n})\nconst data = await dataResp.json()\nhopp.env.active.set('workflow_auth_header', data.headers['Authorization'])\n",
      "testScript": "hopp.test('Sequential requests work', () => {\n  hopp.expect(hopp.env.active.get('seq_step1')).toBe('1')\n  hopp.expect(hopp.env.active.get('seq_step2')).toBe('2')\n  hopp.expect(hopp.env.active.get('seq_prev')).toBe('1')\n})\n\nhopp.test('Parallel requests work', () => {\n  hopp.expect(hopp.env.active.get('parallel_id1')).toBe('1')\n  hopp.expect(hopp.env.active.get('parallel_id2')).toBe('2')\n  hopp.expect(hopp.env.active.get('parallel_id3')).toBe('3')\n})\n\nhopp.test('Auth workflow works', () => {\n  const token = hopp.env.active.get('workflow_token')\n  hopp.expect(token).toInclude('login_token_testuser')\n  hopp.expect(hopp.env.active.get('workflow_auth_header')).toBe(`Bearer ${token}`)\n})\n\n// Test 4: Complex workflow in test with mixed async\nhopp.test('Complex workflow in test works', async () => {\n  // First request with await\n  const r1 = await hopp.fetch('https://echo.hoppscotch.io?workflow=start')\n  const d1 = await r1.json()\n  const workflowId = d1.args.workflow\n  \n  // Second request with .then chaining\n  await hopp.fetch(`https://echo.hoppscotch.io?workflow=${workflowId}&step=2`)\n    .then(r => r.json())\n    .then(d => {\n      hopp.expect(d.args.workflow).toBe('start')\n      hopp.expect(d.args.step).toBe('2')\n    })\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_d5fadf5b-100a-4354-97e9-9756eb494f05"
    },
    {
      "v": "16",
      "id": "error_handling_combined",
      "name": "Error Handling & Edge Cases",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Error handling with try/catch\nlet errorOccurred = false\ntry {\n  const response = await hopp.fetch('https://echo.hoppscotch.io')\n  if (!response.ok) {\n    errorOccurred = true\n  }\n  hopp.env.active.set('fetch_success', 'true')\n} catch (error) {\n  errorOccurred = true\n  hopp.env.active.set('fetch_success', 'false')\n}\nhopp.env.active.set('error_occurred', errorOccurred.toString())\n\n// Test 2: Bearer token auth (using httpbin.org for CORS compatibility)\nconst token = 'sample_bearer_token_abc123'\nconst authResp = await hopp.fetch('https://httpbin.org/get', {\n  headers: { 'Authorization': `Bearer ${token}` }\n})\nconst authData = await authResp.json()\nhopp.env.active.set('sent_auth_header', authData.headers['Authorization'] || 'missing')\n\n// Test 3: Content negotiation headers (using httpbin.org for CORS compatibility)\nconst contentResp = await hopp.fetch('https://httpbin.org/get', {\n  headers: {\n    'Accept': 'application/json, text/plain, */*',\n    'Accept-Language': 'en-US,en;q=0.9',\n    'Accept-Encoding': 'gzip, deflate, br'\n  }\n})\nconst contentData = await contentResp.json()\nhopp.env.active.set('accept_header', contentData.headers['Accept'] || 'missing')\n",
      "testScript": "hopp.test('Error handling works', () => {\n  hopp.expect(hopp.env.active.get('fetch_success')).toBe('true')\n  hopp.expect(hopp.env.active.get('error_occurred')).toBe('false')\n})\n\nhopp.test('Bearer token auth works', () => {\n  const token = 'sample_bearer_token_abc123'\n  hopp.expect(hopp.env.active.get('sent_auth_header')).toBe(`Bearer ${token}`)\n})\n\nhopp.test('Content negotiation works', () => {\n  hopp.expect(hopp.env.active.get('accept_header')).toInclude('application/json')\n})\n\n// Test error handling in test script with .then().catch()\nhopp.test('Error handling with .catch() works', () => {\n  return hopp.fetch('https://echo.hoppscotch.io')\n    .then(r => {\n      hopp.expect(r.ok).toBe(true)\n      return r.json()\n    })\n    .then(d => {\n      hopp.expect(d.method).toBe('GET')\n    })\n    .catch(error => {\n      hopp.expect(true).toBe(false) // Should not reach here\n    })\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_01c75b88-0375-4b3c-86a2-d8cbe7068760"
    },
    {
      "v": "16",
      "id": "large_payload_formdata",
      "name": "Large Payload & FormData",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Large JSON payload with .then pattern\nconst largePayload = {\n  items: Array.from({ length: 100 }, (_, i) => ({\n    id: i,\n    name: `Item ${i}`,\n    description: `Description for item ${i}`,\n    metadata: {\n      created: new Date().toISOString(),\n      index: i,\n      active: i % 2 === 0\n    }\n  }))\n}\n\nhopp.fetch('https://echo.hoppscotch.io', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(largePayload)\n}).then(r => r.json()).then(d => {\n  const receivedData = JSON.parse(d.data)\n  hopp.env.active.set('large_count', receivedData.items.length.toString())\n  hopp.env.active.set('large_first_id', receivedData.items[0].id.toString())\n  hopp.env.active.set('large_last_id', receivedData.items[99].id.toString())\n})\n\n// Test 2: FormData handling (if available)\ntry {\n  if (typeof FormData !== 'undefined') {\n    const formData = new FormData()\n    formData.append('field1', 'value1')\n    formData.append('field2', 'value2')\n    const formResp = await hopp.fetch('https://echo.hoppscotch.io', {\n      method: 'POST',\n      body: formData\n    })\n    const formRespData = await formResp.json()\n    hopp.env.active.set('formdata_status', formResp.status.toString())\n  } else {\n    hopp.env.active.set('formdata_status', 'skipped')\n  }\n} catch (error) {\n  hopp.env.active.set('formdata_status', 'error')\n}\n",
      "testScript": "hopp.test('Large JSON payload works', () => {\n  hopp.expect(hopp.env.active.get('large_count')).toBe('100')\n  hopp.expect(hopp.env.active.get('large_first_id')).toBe('0')\n  hopp.expect(hopp.env.active.get('large_last_id')).toBe('99')\n})\n\nhopp.test('FormData handling works', () => {\n  const status = hopp.env.active.get('formdata_status')\n  if (status === 'skipped') {\n    hopp.expect(status).toBe('skipped')\n  } else {\n    hopp.expect(status).toBe('200')\n  }\n})\n\n// Test large payload in test script with async/await\nhopp.test('Large payload in test script works', async () => {\n  const payload = {\n    data: Array.from({ length: 50 }, (_, i) => ({ index: i, value: `test_${i}` }))\n  }\n  const response = await hopp.fetch('https://echo.hoppscotch.io', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(payload)\n  })\n  const data = await response.json()\n  const received = JSON.parse(data.data)\n  hopp.expect(received.data.length).toBe(50)\n  hopp.expect(received.data[0].index).toBe(0)\n  hopp.expect(received.data[49].value).toBe('test_49')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_39f9f104-e0a1-4df0-9c08-b49c8f96ec4f"
    },
    {
      "v": "16",
      "id": "dynamic_url_construction",
      "name": "Dynamic URL Construction",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Dynamic URL building with template literals and mixed async\nconst baseUrl = 'https://echo.hoppscotch.io'\nconst endpoint = '/api/users'\nconst params = {\n  page: 1,\n  limit: 10,\n  sort: 'name',\n  filter: 'active'\n}\n\nconst queryString = Object.entries(params)\n  .map(([key, value]) => `${key}=${value}`)\n  .join('&')\n\nconst fullUrl = `${baseUrl}${endpoint}?${queryString}`\n\nawait hopp.fetch(fullUrl)\n  .then(r => r.json())\n  .then(d => {\n    hopp.env.active.set('dynamic_path', d.path || 'missing')\n    hopp.env.active.set('param_page', d.args.page)\n    hopp.env.active.set('param_limit', d.args.limit)\n    hopp.env.active.set('param_sort', d.args.sort)\n  })\n",
      "testScript": "hopp.test('Dynamic URL construction works', () => {\n  hopp.expect(hopp.env.active.get('dynamic_path')).toInclude('/api/users')\n  hopp.expect(hopp.env.active.get('param_page')).toBe('1')\n  hopp.expect(hopp.env.active.get('param_limit')).toBe('10')\n  hopp.expect(hopp.env.active.get('param_sort')).toBe('name')\n})\n\n// Test dynamic URL in test script with .then\nhopp.test('Dynamic URL in test script works', () => {\n  const base = 'https://echo.hoppscotch.io'\n  const path = '/test/path'\n  const query = '?key=value'\n  \n  return hopp.fetch(`${base}${path}${query}`)\n    .then(r => r.json())\n    .then(d => {\n      hopp.expect(d.path).toInclude('/test/path')\n      hopp.expect(d.args.key).toBe('value')\n    })\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_mhpz2fsl_04af11e2-e7b0-4312-a833-d676af5ee761"
    },
    {
      "v": "16",
      "id": "pm_sendrequest_callback",
      "name": "pm.sendRequest - Callback API",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: pm.sendRequest with string URL and callback\npm.sendRequest('https://echo.hoppscotch.io?test=callback', (error, response) => {\n  if (error) {\n    pm.environment.set('callback_error', 'true')\n  } else {\n    pm.environment.set('callback_status', response.code.toString())\n    pm.environment.set('callback_arg', response.json().args.test)\n  }\n})\n\n// Test 2: pm.sendRequest with request object format\npm.sendRequest({\n  url: 'https://echo.hoppscotch.io',\n  method: 'POST',\n  header: [\n    { key: 'Content-Type', value: 'application/json' },\n    { key: 'X-Test-Header', value: 'test123' }\n  ],\n  body: {\n    mode: 'raw',\n    raw: JSON.stringify({ name: 'pm.sendRequest', type: 'callback' })\n  }\n}, (error, response) => {\n  if (!error) {\n    const body = JSON.parse(response.json().data)\n    pm.environment.set('pm_sendrequest_name', body.name)\n    pm.environment.set('pm_sendrequest_type', body.type)\n    pm.environment.set('pm_sendrequest_method', response.json().method)\n  }\n})\n\n// Test 3: pm.sendRequest with urlencoded body\npm.sendRequest({\n  url: 'https://httpbin.org/post',\n  method: 'POST',\n  body: {\n    mode: 'urlencoded',\n    urlencoded: [\n      { key: 'username', value: 'testuser' },\n      { key: 'password', value: 'testpass' }\n    ]\n  }\n}, (error, response) => {\n  if (!error) {\n    const data = response.json()\n    pm.environment.set('urlencoded_username', data.form.username)\n    pm.environment.set('urlencoded_password', data.form.password)\n  }\n})\n\n// Test 4: pm.sendRequest with environment variables\npm.environment.set('API_BASE', 'https://echo.hoppscotch.io')\npm.environment.set('API_TOKEN', 'Bearer test-token-123')\n\nconst apiUrl = pm.environment.get('API_BASE') + '/api/data'\nconst token = pm.environment.get('API_TOKEN')\n\npm.sendRequest({\n  url: apiUrl,\n  header: [\n    { key: 'Authorization', value: token }\n  ]\n}, (error, response) => {\n  if (!error) {\n    pm.environment.set('env_integration_status', response.code.toString())\n    pm.environment.set('env_integration_path', response.json().path)\n  }\n})\n",
      "testScript": "pm.test('pm.sendRequest string URL callback works', () => {\n  pm.expect(pm.environment.get('callback_status')).to.eql('200')\n  pm.expect(pm.environment.get('callback_arg')).to.eql('callback')\n})\n\npm.test('pm.sendRequest object format works', () => {\n  pm.expect(pm.environment.get('pm_sendrequest_name')).to.eql('pm.sendRequest')\n  pm.expect(pm.environment.get('pm_sendrequest_type')).to.eql('callback')\n  pm.expect(pm.environment.get('pm_sendrequest_method')).to.eql('POST')\n})\n\npm.test('pm.sendRequest urlencoded body works', () => {\n  pm.expect(pm.environment.get('urlencoded_username')).to.eql('testuser')\n  pm.expect(pm.environment.get('urlencoded_password')).to.eql('testpass')\n})\n\npm.test('pm.sendRequest environment variable integration works', () => {\n  pm.expect(pm.environment.get('env_integration_status')).to.eql('200')\n  pm.expect(pm.environment.get('env_integration_path')).to.include('/api/data')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_fetch_api_pmsendrequest_01"
    },
    {
      "v": "16",
      "id": "fetch_api_headers_class",
      "name": "Fetch API - Headers Class",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Headers constructor with object\nconst headers1 = new Headers({\n  'Content-Type': 'application/json',\n  'X-Custom-Header': 'value123'\n})\n\nhopp.env.active.set('headers_has_ct', headers1.has('content-type').toString())\nhopp.env.active.set('headers_get_custom', headers1.get('x-custom-header'))\n\n// Test 2: Headers methods - append, set, delete\nconst headers2 = new Headers()\nheaders2.append('Accept', 'application/json')\nheaders2.append('Accept', 'text/plain') // Multiple values\nheaders2.set('Authorization', 'Bearer token123')\nheaders2.set('X-API-Key', 'key456')\nheaders2.delete('X-API-Key')\n\nhopp.env.active.set('headers_accept', headers2.get('Accept'))\nhopp.env.active.set('headers_auth', headers2.get('Authorization'))\nhopp.env.active.set('headers_deleted', (headers2.get('X-API-Key') === null).toString())\n\n// Test 3: Headers iteration - entries, keys, values\nconst headers3 = new Headers({\n  'Content-Type': 'application/json',\n  'Accept': 'application/json',\n  'Authorization': 'Bearer test'\n})\n\nlet keyCount = 0\nfor (const key of headers3.keys()) {\n  keyCount++\n}\n\nlet entryCount = 0\nfor (const [key, value] of headers3.entries()) {\n  entryCount++\n}\n\nhopp.env.active.set('headers_key_count', keyCount.toString())\nhopp.env.active.set('headers_entry_count', entryCount.toString())\n\n// Test 4: Headers with fetch\nconst headers4 = new Headers({\n  'X-Test-Header': 'fetch-with-headers',\n  'Content-Type': 'application/json'\n})\n\nconst response = await hopp.fetch('https://httpbin.org/get', {\n  headers: headers4\n})\n\nconst data = await response.json()\nhopp.env.active.set('fetch_custom_header', data.headers['X-Test-Header'])\n",
      "testScript": "hopp.test('Headers constructor works', () => {\n  hopp.expect(hopp.env.active.get('headers_has_ct')).toBe('true')\n  hopp.expect(hopp.env.active.get('headers_get_custom')).toBe('value123')\n})\n\nhopp.test('Headers append and set work', () => {\n  hopp.expect(hopp.env.active.get('headers_accept')).toInclude('application/json')\n  hopp.expect(hopp.env.active.get('headers_auth')).toBe('Bearer token123')\n})\n\nhopp.test('Headers delete works', () => {\n  hopp.expect(hopp.env.active.get('headers_deleted')).toBe('true')\n})\n\nhopp.test('Headers iteration works', () => {\n  hopp.expect(hopp.env.active.get('headers_key_count')).toBe('3')\n  hopp.expect(hopp.env.active.get('headers_entry_count')).toBe('3')\n})\n\nhopp.test('Headers work with fetch', () => {\n  hopp.expect(hopp.env.active.get('fetch_custom_header')).toBe('fetch-with-headers')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_fetch_api_headers_01"
    },
    {
      "v": "16",
      "id": "fetch_api_request_response",
      "name": "Fetch API - Request & Response Classes",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: Request class constructor\nconst request1 = new Request('https://echo.hoppscotch.io', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({ test: 'request-class' })\n})\n\nhopp.env.active.set('request_url', request1.url)\nhopp.env.active.set('request_method', request1.method)\n\n// Test 2: Request clone\nconst request2 = new Request('https://echo.hoppscotch.io/api/users', {\n  method: 'GET',\n  headers: { 'Authorization': 'Bearer token' }\n})\n\nconst clonedRequest = request2.clone()\nhopp.env.active.set('cloned_url', clonedRequest.url)\nhopp.env.active.set('cloned_method', clonedRequest.method)\n\n// Test 3: Response class constructor\nconst response1 = new Response(JSON.stringify({ success: true, data: 'test' }), {\n  status: 200,\n  statusText: 'OK',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n})\n\nhopp.env.active.set('response_status', response1.status.toString())\nhopp.env.active.set('response_ok', response1.ok.toString())\n\n// Test json() and text() methods\nconst jsonData = await response1.json()\nhopp.env.active.set('response_json_success', jsonData.success.toString())\nhopp.env.active.set('response_json_data', jsonData.data)\n\n// Test 4: Response clone\nconst response2 = new Response('clone test data', {\n  status: 201,\n  statusText: 'Created'\n})\n\nconst clonedResponse = response2.clone()\nhopp.env.active.set('cloned_response_status', clonedResponse.status.toString())\n\n// Test 5: Using Request with fetch (if supported)\ntry {\n  const fetchRequest = new Request('https://echo.hoppscotch.io?from=request', {\n    method: 'GET'\n  })\n  \n  const fetchResp = await hopp.fetch(fetchRequest.url)\n  const fetchData = await fetchResp.json()\n  hopp.env.active.set('request_fetch_arg', fetchData.args.from)\n} catch (error) {\n  hopp.env.active.set('request_fetch_arg', 'error')\n}\n",
      "testScript": "hopp.test('Request class constructor works', () => {\n  hopp.expect(hopp.env.active.get('request_url')).toBe('https://echo.hoppscotch.io')\n  hopp.expect(hopp.env.active.get('request_method')).toBe('POST')\n})\n\nhopp.test('Request clone works', () => {\n  hopp.expect(hopp.env.active.get('cloned_url')).toBe('https://echo.hoppscotch.io/api/users')\n  hopp.expect(hopp.env.active.get('cloned_method')).toBe('GET')\n})\n\nhopp.test('Response class constructor works', () => {\n  hopp.expect(hopp.env.active.get('response_status')).toBe('200')\n  hopp.expect(hopp.env.active.get('response_ok')).toBe('true')\n})\n\nhopp.test('Response json() method works', () => {\n  hopp.expect(hopp.env.active.get('response_json_success')).toBe('true')\n  hopp.expect(hopp.env.active.get('response_json_data')).toBe('test')\n})\n\nhopp.test('Response clone works', () => {\n  hopp.expect(hopp.env.active.get('cloned_response_status')).toBe('201')\n})\n\nhopp.test('Request works with fetch', () => {\n  hopp.expect(hopp.env.active.get('request_fetch_arg')).toBe('request')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_fetch_api_request_response_01"
    },
    {
      "v": "16",
      "id": "fetch_api_abortcontroller",
      "name": "Fetch API - AbortController",
      "method": "GET",
      "endpoint": "https://echo.hoppscotch.io",
      "params": [],
      "headers": [],
      "preRequestScript": "// Test 1: AbortController creation\nconst controller1 = new AbortController()\nconst signal1 = controller1.signal\n\nhopp.env.active.set('controller_exists', (controller1 !== null).toString())\nhopp.env.active.set('signal_exists', (signal1 !== null).toString())\nhopp.env.active.set('signal_aborted_initial', signal1.aborted.toString())\n\n// Test 2: AbortController abort method\nconst controller2 = new AbortController()\nconst signal2 = controller2.signal\n\nhopp.env.active.set('signal_before_abort', signal2.aborted.toString())\ncontroller2.abort()\nhopp.env.active.set('signal_after_abort', signal2.aborted.toString())\n\n// Test 3: AbortSignal event listener\nconst controller3 = new AbortController()\nconst signal3 = controller3.signal\n\nlet abortEventFired = false\nsignal3.addEventListener('abort', () => {\n  abortEventFired = true\n})\n\ncontroller3.abort()\nhopp.env.active.set('abort_event_fired', abortEventFired.toString())\n\n// Test 4: Multiple listeners\nconst controller4 = new AbortController()\nconst signal4 = controller4.signal\n\nlet listener1Called = false\nlet listener2Called = false\n\nsignal4.addEventListener('abort', () => { listener1Called = true })\nsignal4.addEventListener('abort', () => { listener2Called = true })\n\ncontroller4.abort()\n\nhopp.env.active.set('multiple_listeners', (listener1Called && listener2Called).toString())\n\n// Test 5: AbortController with fetch (note: actual abort functionality depends on fetch implementation)\nconst controller5 = new AbortController()\nconst signal5 = controller5.signal\n\ntry {\n  const promise = hopp.fetch('https://echo.hoppscotch.io?test=abort')\n  // Don't actually abort mid-request for this test, just verify signal can be passed\n  const response = await promise\n  const data = await response.json()\n  hopp.env.active.set('abort_test_arg', data.args.test)\n} catch (error) {\n  hopp.env.active.set('abort_test_arg', 'error')\n}\n",
      "testScript": "hopp.test('AbortController can be created', () => {\n  hopp.expect(hopp.env.active.get('controller_exists')).toBe('true')\n  hopp.expect(hopp.env.active.get('signal_exists')).toBe('true')\n})\n\nhopp.test('AbortSignal initial state is not aborted', () => {\n  hopp.expect(hopp.env.active.get('signal_aborted_initial')).toBe('false')\n})\n\nhopp.test('AbortController abort() changes signal state', () => {\n  hopp.expect(hopp.env.active.get('signal_before_abort')).toBe('false')\n  hopp.expect(hopp.env.active.get('signal_after_abort')).toBe('true')\n})\n\nhopp.test('AbortSignal event listener fires on abort', () => {\n  hopp.expect(hopp.env.active.get('abort_event_fired')).toBe('true')\n})\n\nhopp.test('Multiple abort listeners work', () => {\n  hopp.expect(hopp.env.active.get('multiple_listeners')).toBe('true')\n})\n\nhopp.test('AbortController works with fetch', () => {\n  hopp.expect(hopp.env.active.get('abort_test_arg')).toBe('abort')\n})\n",
      "auth": {
        "authType": "inherit",
        "authActive": true
      },
      "body": {
        "contentType": null,
        "body": null
      },
      "requestVariables": [],
      "responses": {},
      "_ref_id": "req_fetch_api_abortcontroller_01"
    }
  ],
  "auth": {
    "authType": "inherit",
    "authActive": true
  },
  "headers": [],
  "variables": [],
  "_ref_id": "coll_mhpztv1l_04b5415c-027e-4499-9a5b-6a0f36ec8129"
}